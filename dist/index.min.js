class Matrix {
    constructor(row, col) {
        if (row % 1 || col % 1) {
            //小数なら中断
            return false;
        }
        this.elements = new Array(row * col);
        this.elements.fill(0); //初期化処理
        this.row = row;
        this.col = col;
    }
    init() {
        if (row % 1 || col % 1) {
            //小数なら中断
            return false;
        }
        this.elements = new Array(row * col);
        this.elements.fill(0); //初期化処理
        this.row = row;
        this.col = col;
    }
    set(value) {
        this.elements = value;
    }

    reset(row, col) {
        if (row % 1 || col % 1) {
            //小数なら中断
            return false;
        }
        this.elements = new Array(row * col);
        this.elements.fill(0); //初期化処理
        this.row = row;
        this.col = col;
    }

    getElement(i, j) {
        return this.elements[i * this.col + j];
    }

    setElement(i, j, value) {
        this.elements[i * this.col + j] = value;
    }

    getByIndex(index) {
        return this.elements[index];
    }

    setByIndex(index, value) {
        this.elements[index] = value;
    }

    getDimension() {
        return Math.sqrt(this.elements.length);
    }

    getRow() {
        return this.row;
    }

    getCol() {
        return this.col;
    }

    static log(mat) {
        let tableLog = new Array(this.row);
        for (let m = 0; m < mat.row; m++) {
            let t = new Array(this.col);
            for (let n = 0; n < mat.col; n++) {
                t[n] = mat.elements[n + m * mat.col];
            }
            tableLog[m] = t;
        }
        return tableLog;
    }

    static makeNorm(vec) {
        //正規化，単位ベクトル化．
        var mx = new Matrix(3, 1);
        var e = Math.sqrt(vec.getElement(0, 0) ** 2 + vec.getElement(1, 0) ** 2 + vec.getElement(2, 0) ** 2);
        e = (1 / e);
        for (var i = 0; i < 3; i++) {
            mx.setElement(i, 0, vec.getElement(i, 0) * e);
        }
        return mx;
    }

    static makeTranslation(x, y, z) {
        var translation = this.makeScale(1, 1, 1);
        translation.setElement(0, 3, x);
        translation.setElement(1, 3, y);
        translation.setElement(2, 3, z);
        return translation;
    }

    static add(mat, mat2) {
        var m, n;
        var mx = new Matrix(mat.getRow(), mat.getCol());
        for (m = 0; m < mat.getRow(); m++) {
            for (n = 0; n < mat.getCol(); n++) {
                mx.setElement(m, n, mat.getElement(m, n) + mat2.getElement(m, n));
            }
        }
        return mx;
    }

    static Invert(mat) {
        const mx = new Matrix(mat.getRow(), mat.getCol());
        for (let m = 0; m < mat.getRow(); m++) {
            for (let n = 0; n < mat.getCol(); n++) {
                mx.setElement(m, n, -mat.getElement(m, n));
            }
        }
        return mx;
    }

    static makeScale(x, y, z) {
        var mx_S = new Matrix(4, 4);
        mx_S.elements = [
            x, 0, 0, 0,
            0, y, 0, 0,
            0, 0, z, 0,
            0, 0, 0, 1
        ];
        return mx_S;
    }

    static makeTranslationByMatrix(mat) {
        return this.makeTranslation(mat.getElement(0, 0), mat.getElement(1, 0), mat.getElement(2, 0))
    }

    static translateByMatrix(translater, target) {
        return this.multiply(this.makeTranslationByMatrix(translater), target)
    }

    static translate(mat, x, y, z) {
        return this.multiply(this.makeTranslation(x, y, z), mat);
    }

    static multiplyByScalar(scalar, mat) {
        var m, n;
        var transformed_mx = new Matrix(mat.getRow(), mat.getCol());

        for (m = 0; m < mat.getRow(); m++) {
            for (n = 0; n < mat.getCol(); n++) {
                //console.log(mat.getElement(m,n));
                transformed_mx.setElement(m, n, scalar * mat.getElement(m, n));
            }
        }
        return transformed_mx;
    }

    static multiply(multiplier, target) {
        if (multiplier.col != target.row) {
            //列と行が一致するか判定．
            return false;
        }
        var m, n, l, t;
        // m means row_index.
        // n means col_index.
        var transformed_matrix = new Matrix(multiplier.getRow(), target.getCol());
        for (m = 0; m < multiplier.getRow(); m++) {
            for (l = 0; l < target.getCol(); l++) {
                t = 0;
                for (n = 0; n < multiplier.getCol(); n++) {
                    t += multiplier.getElement(m, n) * target.getElement(n, l);
                }
                transformed_matrix.setElement(m, l, t);
            }
        }
        return transformed_matrix;
    }

    static makeSubMatrix(mat, i, j) {
        var mx = new Matrix(mat.row - 1, mat.row - 1);
        var m, n, index;
        index = 0;
        for (m = 0; m < mat.row; m++) {
            if (m == i) {
                continue;
            }
            for (n = 0; n < mat.col; n++) {
                if (n == j) {
                    continue;
                }
                mx.setByIndex(index, mat.getElement(m, n));
                index++;
            }
        }
        return mx;
    }

    static det(mat) {
        var m, t, dim;
        t = 0;
        dim = mat.getDimension();
        if (dim == 1) {
            return mat.getByIndex(0);
        }
        for (m = 0; m < dim; m++) {
            t += (-1) ** m * mat.getElement(0, m) * this.det(this.makeSubMatrix(mat, 0, m));
        }
        return t;
    }

    static transformFromWorldToView(mat) {
    }


    static makeRotationY(radian) {
        const mx = new Matrix(4, 4)
        mx.elements = [
            Math.cos(radian), 0, Math.sin(radian), 0,
            0, 1, 0, 0,
            -Math.sin(radian), 0, Math.cos(radian), 0,
            0, 0, 0, 1
        ]
        return mx
    }

    static makeAdjugate(mat) {
        var m, n, t, dim, mx;
        mx = new Matrix(mat.getRow(), mat.getCol());
        dim = mat.getDimension();
        t = 0;
        if (dim == 1) {
            return mat.getByIndex(0);
        }
        for (m = 0; m < dim; m++) {
            for (n = 0; n < dim; n++) {
                t = (-1) ** (m + n) * this.det(this.makeSubMatrix(mat, n, m));
                mx.setElement(m, n, t);
            }
        }
        return mx;
    }

    static makeInverse(mat) {
        var d, mx_a;
        d = this.det(mat);
        mx_a = this.Adjugate(mat);
        console.log(mx_a);
        mx_inv = this.MultiplyByScalar(1 / d, mx_a);
        return mx_inv;
    }

    static dot(vec1, vec2) {
        return vec1.getElement(0, 0) * vec2.getElement(0, 0) + vec1.getElement(1, 0) * vec2.getElement(1, 0) + vec1.getElement(2, 0) * vec2.getElement(2, 0);
    }

    static cross(vec1, vec2) {
        var mx = new Matrix(3, 1);
        mx.elements = [
            vec1.getElement(1, 0) * vec2.getElement(2, 0) - vec1.getElement(2, 0) * vec2.getElement(1, 0),
            vec1.getElement(2, 0) * vec2.getElement(0, 0) - vec1.getElement(0, 0) * vec2.getElement(2, 0),
            vec1.getElement(0, 0) * vec2.getElement(1, 0) - vec1.getElement(1, 0) * vec2.getElement(0, 0)
        ];
        return mx;
    }

    static transpose(mat) {
        var mx = new Matrix(mat.getRow(), mat.getRow());
        for (var m = 0; m < mat.getRow(); m++) {
            for (var n = 0; n < mat.getRow(); n++) {
                mx.setElement(m, n, mat.getElement(n, m));
            }
        }
        return mx;
    }

    static makeVert(x, y, z) {
        const v = new Matrix(4, 1)
        if(arguments.length!=3){
            console.error("頂点座標を正しく入力してください")
            return
        }
        v.setElement(0, 0, x)
        v.setElement(1, 0, y)
        v.setElement(2, 0, z)
        v.setElement(3, 0, 1)
        return v
    }
}

class Point extends Matrix{
    constructor(){
        super(4,1)
    }
}

module.exports = {
    Matrix,
    Point
}

const { Matrix, Point } = require("./Matrix");
const { Vector3, Vector4, Matrix4, Quaternion } = require('./matrixgl.min.js');
class Poly {
  constructor() {
    this.origin = new Point()
    if (arguments.length == 0) {
      this.origin.elements = [
        0,
        0,
        0,
        1
      ]
    }
    else {
      this.origin = arguments[0]
    }
    this.verts = [];
    this.rotY = Matrix.makeRotationY(0)
    this.bClosed = true
    this.scale = Matrix.makeScale(1, 1, 1)
  }

  setScale(mx) {
    this.scale = mx
  }

  setRotationY(mx) {
    this.rotY = mx
  }

  setClosed() {
    this.bClosed = true
  }
  IsClosed() {
    return this.bClosed
  }

  setUnclosed() {
    this.bClosed = false
  }

  setOrigin(OriginMatrix) {
    this.origin = OriginMatrix
  }

  addVert(vec) {
    this.verts.push(vec);
  }

  translate(mx) {
    const v = []
    for (const key in this.verts) {
      if (Object.hasOwnProperty.call(this.verts, key)) {
        const element = this.verts[key];
        v.push(Matrix.multiply(mx,))
      }
    }
  }

  scale(mx) {
    const v = []
    for (const key in this.verts) {
      if (Object.hasOwnProperty.call(this.verts, key)) {
        const element = this.verts[key];
        v.push(Matrix.multiply)
      }
    }
  }

  Transform(mx) {
    const v = []
    for (const key in this.verts) {
      if (Object.hasOwnProperty.call(this.verts, key)) {
        const element = this.verts[key];
        v.push(Matrix.multiply(mx, element))
      }
    }
    return v
  }

  TransformOverride(mx) {
    for (const key in this.verts) {
      if (Object.hasOwnProperty.call(this.verts, key)) {
        this.verts[key] = Matrix.multiply(mx, this.verts[key])
      }
    }
  }


  rotateYOverride(radian) {
    let mx_rot = Matrix.makeRotationY(radian)

    for (const key in this.verts) {
      if (Object.hasOwnProperty.call(this.verts, key)) {
        this.verts[key] = Matrix.multiply(mx_rot, this.verts[key])
      }
    }
  }

  getVertsWorld() {
    const worldVerts = []
    for (const key in this.verts) {
      if (Object.hasOwnProperty.call(this.verts, key)) {
        const element = this.verts[key];
        worldVerts.push(Matrix.translateByMatrix(this.origin, element))
      }
    }
    return worldVerts
  }


  static createLine(v1, v2) {
    const p = new Poly();
    p.addVert(v1);
    p.addVert(v2);
    return p;
  }

  static createPoly(...args) {
    for (const key in arguments) {
      if (Object.hasOwnProperty.call(arguments, key)) {
        const element = arguments[key];
        poly_ins = new Poly()
        poly_ins.verts.push(element);
      }
    }
    return poly_ins
  }

  static addPerspectives() {
  }

  static createPolyFromPath(pathItem) {
    for (const key in pathItem) {
      if (Object.hasOwnProperty.call(pathItem, key)) {
        const element = pathItem[key];
        console.log(element);
      }
    }
  }
  static createPlane() {
    console.error("This F does nothing.")
  }
}
exports.Poly = Poly;

const { Matrix } = require("./Matrix");
const { Poly } = require("./Poly");

class PrimitiveBase {
    constructor(OriginMatrix, ScaleMatrix, RotationMatrix) {
        this.loc = OriginMatrix
        this.scl = ScaleMatrix
        this.rot = RotationMatrix
        this.poly=new Poly();
        this.poly.setOrigin(OriginMatrix)
        console.log("プリミティブが作成されました")
        this.createPoly()
    }

    createPoly(){
        console.error("基底クラスが呼び出されました．この関数は無効です")
        return false
    }

    setLocation(matrix){
        this.loc=matrix
    }

    setScale(matrix){
        this.scl=matrix
    }
}

class PrimitivePlane extends PrimitiveBase{
    createPoly(){
        this.poly.verts.push(Matrix.makeVert(0.5,0.5,0))
        this.poly.verts.push(Matrix.makeVert(-0.5,0.5,0))
        this.poly.verts.push(Matrix.makeVert(-0.5,-0.5,0))
        this.poly.verts.push(Matrix.makeVert(0.5,-0.5,0))
        this.poly.setClosed()
        console.log("平面を作成")

        this.poly.TransformOverride(this.rot)
    }

    getPoly(){
        return this.poly
    }
    IsClosed(){
        return this.poly.IsClosed()
    }
}

class PrimitiveBox extends PrimitiveBase{
}

module.exports = {
    PrimitivePlane
}
const { Matrix } = require("./Matrix");
const { Poly } = require("./Poly");

class MultiPoly {
  constructor() {
    this.origin=Matrix.makeVert(0,0,0)
    if(arguments.length!=0){
      this.origin=arguments[0]
    }
    this.polys = [];

    this.rotY=Matrix.makeRotationY(0)
    this.scl=Matrix.makeScale(1,1,1)
    this.loc=Matrix.makeTranslation(0,0,0)
  }

  addPoly(poly) {
    this.polys.push(poly);
  }
  
  static createMultiPolyFromPath(pathItem) {
    const mp = new MultiPoly();
    for (let index = 0; index < pathItem.subPathItems.length; index++) {
      const p = new Poly();
      const subPaths = pathItem.subPathItems[index];
      for (let indexj = 0; indexj < subPaths.pathPoints.length; indexj++) {
        const point = subPaths.pathPoints[indexj];
        const vert = new Matrix(4, 1);
        vert.elements = [
          point.anchor[0],
          0,
          point.anchor[1],
          1
        ];
        p.addVert(vert);
      }
      console.log(p);
      mp.addPoly(p);
    }
    console.log(mp);
    return mp;
  }

  rotateY(radian){

  }
}
exports.MultiPoly = MultiPoly;

const { Matrix } = require("./Matrix");

class Camera {
  constructor(CameraPos, TargetPos, w_dis, wvsize, whsize, z_m, zchilda, zmi, c_width, c_height) {
    this.location = new Matrix(3, 1);
    this.location.elements = [
      CameraPos[0],
      CameraPos[1],
      CameraPos[2]
    ];

    console.log("カメラ座標", this.location);
    this.targetLoc = new Matrix(3, 1);
    this.targetLoc.elements = [
      TargetPos[0],
      TargetPos[1],
      TargetPos[2]
    ];

    this.canv_width = c_width;
    this.canv_height = c_height;

    this.axis = [new Matrix(3, 1), new Matrix(3, 1), new Matrix(3, 1)];

    this.w_distance = w_dis;
    this.w_hSize = whsize;
    this.w_vSize = wvsize;
    this.zMax = z_m;
    this.z_dash_min = zchilda;
    this.zMin = zmi;
    this.shift_x = 0
    this.shift_y = 0

    this.calcAxis();
    this.mn = this.makeNormalize();
    this.mt = this.makeCameraTransform();
    this.mp = this.makeProjection();
    this.mx_ViewToScr = this.makeViewToScr();
    this.scaleI = Matrix.makeScale(1, 1, 1);
  }

  calcTargetVec() {
    var vec = new Matrix(3, 1);
    console.log("TargetLoc", this.targetLoc, "Inverted", Matrix.Invert(this.location));
    vec = Matrix.add(this.targetLoc, Matrix.Invert(this.location));
    vec = Matrix.makeNorm(vec);
    vec = Matrix.Invert(vec);
    console.table("Z vector:", vec);
    return vec;
  }

  calcAxis() {
    this.axis[2] = this.calcTargetVec();
    this.axis[1].elements = [
      0,
      1,
      0
    ];

    this.axis[0] = Matrix.makeNorm(Matrix.cross(this.axis[2], this.axis[1]));
    this.axis[1] = Matrix.makeNorm(Matrix.cross(this.axis[0], this.axis[2]));

    console.table("axis Right", this.axis[0]);
    console.table("axis Up", this.axis[1]);
    console.table("axis Front", this.axis[2]);
  }

  makeCameraTransform() {
    var mx = new Matrix(4, 4);
    mx.elements = [
      this.axis[0].getElement(0, 0), this.axis[0].getElement(0, 1), this.axis[0].getElement(0, 2), -Matrix.dot(this.axis[0], this.location),
      this.axis[1].getElement(0, 0), this.axis[1].getElement(0, 1), this.axis[1].getElement(0, 2), -Matrix.dot(this.axis[1], this.location),
      this.axis[2].getElement(0, 0), this.axis[2].getElement(0, 1), this.axis[2].getElement(0, 2), -Matrix.dot(this.axis[2], this.location),
      0, 0, 0, 1
    ];
    return mx;
  }

  makeViewToScr() {
    let mx = new Matrix(4, 4);
    mx.elements = [
      this.canv_width / 2, 0, 0, this.canv_width / 2 + this.canv_width * this.shift_x,
      0, this.canv_height / 2, 0, this.canv_height / 2 + this.canv_height * this.shift_y,
      0, 0, 1, 0,
      0, 0, 0, 1
    ];
    console.table("ターブル", mx);
    return mx;
  }

  makeNormalize() {
    return Matrix.makeScale(this.w_distance / (this.zMax * this.w_hSize), this.w_distance / (this.w_vSize * this.zMax), 1 / this.zMax);
  }

  makeProjection() {
    var mx_P = new Matrix(4, 4);
    mx_P.elements = [
      1, 0, 0, 0,
      0, 1, 0, 0,
      0, 0, 1 / (1 - this.z_dash_min), -this.z_dash_min / (1 - this.z_dash_min),
      0, 0, 1, 0
    ];
    return mx_P;
  }

  Project(vert) {
    vert = Matrix.multiply(this.scaleI, vert);
    vert = Matrix.multiply(this.mt, vert);
    vert = Matrix.multiply(this.mn, vert);
    vert = Matrix.multiply(this.mp, vert);
    vert = Matrix.multiplyByScalar(1 / vert.getElement(3, 0), vert);
    return vert;
  }

  ProjectToScreen(vert) {
    vert = this.Project(vert);
    console.log("変換テスト", Matrix.multiply(this.mx_ViewToScr, vert));
    return Matrix.multiply(this.mx_ViewToScr, vert);
  }

  setShift(x, y) {
    this.shift_x = x
    this.shift_y = y
    this.mx_ViewToScr = this.makeViewToScr();
  }

}

module.exports = {
  Camera
}
const { Matrix } = require("./Matrix");
const { Poly } = require("./Poly");
const { DrawObject, DrawObjectElements } = require("./DrawObject");

class World {
  constructor(CameraInstance) {
    this.multiPolys = [];
    this.instanceCam = CameraInstance;
    console.log("World Initialized");
    this.PersepectivePolys = [];
  }

  addPoly(p) {
    this.multiPolys.push(p);
  }

  createPerse(x, y, z) {
    for (let index = 0; index < z + 1; index++) {
      let vert1 = new Matrix(4, 1);
      let vert2 = new Matrix(4, 1);
      vert1.elements = [
        x,
        0,
        index,
        1
      ];

      vert2.elements = [
        0,
        0,
        index,
        1
      ];
      this.PersepectivePolys.push(Poly.createLine(vert1, vert2));
    }

    for (let index = 0; index < x + 1; index++) {
      let vert1 = new Matrix(4, 1);
      let vert2 = new Matrix(4, 1);
      vert1.elements = [
        index,
        0,
        z,
        1
      ];

      vert2.elements = [
        index,
        0,
        0,
        1
      ];
      this.PersepectivePolys.push(Poly.createLine(vert1, vert2));
    }
    console.log("パースライン", this.PersepectivePolys);
  }

  getScreenLocs(poly) {
    const v_scr = [];
    const verts = poly.getVertsWorld();
    console.table("頂点座標", v_scr);
    for (const key in verts) {
      if (Object.hasOwnProperty.call(verts, key)) {
        const element = verts[key];
        v_scr.push(this.instanceCam.ProjectToScreen(element));
      }
    }

    return v_scr;
  }

  IsClosed(poly) {
    return poly.IsClosed();
  }

  getDrawObject(poly) {
    const pointsOnScreen = [];
    const verts = poly.getVertsWorld();
    for (const key in verts) {
      if (Object.hasOwnProperty.call(verts, key)) {
        const element = verts[key];
        const pMatrix = this.instanceCam.ProjectToScreen(element);
        pointsOnScreen.push([
          pMatrix.getElement(0, 0),
          pMatrix.getElement(1, 0)
        ]);
      }
    }
    console.log("PolyIsClosed", poly.IsClosed());
    const IDrawObjectElements = new DrawObjectElements(pointsOnScreen, poly.IsClosed());

    const IDrawObject = new DrawObject();
    IDrawObject.addElement(IDrawObjectElements);
    return IDrawObject;
  }

  getDrawObjectPerse() {
    const IDrawObject = new DrawObject();
    for (const key in this.PersepectivePolys) {
      if (Object.hasOwnProperty.call(this.PersepectivePolys, key)) {
        const element = this.PersepectivePolys[key];
        console.table("パース", element);
        const startp = this.instanceCam.ProjectToScreen(element.verts[0]);
        const endp = this.instanceCam.ProjectToScreen(element.verts[1]);

        const s_p = [
          startp.getElement(0, 0),
          startp.getElement(1, 0)
        ];
        const e_p = [
          endp.getElement(0, 0),
          endp.getElement(1, 0)
        ];

        IDrawObject.addElement(
          new DrawObjectElements([s_p, e_p], false)
        );

      }
    }

    return IDrawObject;
  }

  getScreenLocations(poly) {
    const pointsOnScreen = [];
    const verts = poly.getVertsWorld();
    for (const key in verts) {
      if (Object.hasOwnProperty.call(verts, key)) {
        const element = verts[key];
        const pMatrix = this.instanceCam.ProjectToScreen(element);
        pointsOnScreen.push([
          pMatrix.getElement(0, 0),
          pMatrix.getElement(1, 0)
        ]);
      }
    }

    const IDrawObject = new DrawObject(pointsOnScreen, poly.IsClosed());

    return IDrawObject;
  }

}
exports.World = World;

class DrawObject{
    constructor(){
        this.elements=[]
    }

    getElements(){
        return this.elements;
    }
    addElement(elem){
        this.elements.push(elem)
    }
}

class DrawObjectElements{
    constructor(points,bClosed){
        this.bClosed=bClosed
        this.points=points
    }

    getPoints(){
        return this.points
    }

    setClosed(){
        this.bClosed=true
    }

    setUnclosed(){
        this.bClosed=false
    }

    IsClosed(){
        return this.bClosed
    }
}

module.exports={
    DrawObject,
    DrawObjectElements
}
const { Matrix, Point } = require("./Matrix");
const { DrawObject, DrawObjectElements } = require("./DrawObject")

class Drawer {
    constructor(app, currentDoc, constants) {
        this.app = app
        this.currentDoc = currentDoc
        this.constants = constants
        console.log("Drawer Initialized")
    }

    async draw(IDrawObject) {
        console.log("DrawCall")
        const spis = []
        const FDrawObject = IDrawObject.getElements()
        for (const key in FDrawObject) {
            if (Object.hasOwnProperty.call(FDrawObject, key)) {
                const DObjectElement = FDrawObject[key];
                const spi = new this.app.SubPathInfo()
                
                spi.closed = DObjectElement.IsClosed()
                spi.operation = this.constants.ShapeOperation.SHAPEXOR
                console.log("ポイント",DObjectElement)
                
                const verts = DObjectElement.getPoints()
                const entirePoint = []
                for (const key in verts) {
                    if (Object.hasOwnProperty.call(verts, key)) {
                        const element = verts[key];
                        console.log(element)
                        const IPathPoint = new this.app.PathPointInfo()
                        IPathPoint.anchor = element
                        IPathPoint.leftDirection = element
                        IPathPoint.rightDirection = element
                        IPathPoint.kind = this.constants.PointKind.CORNERPOINT
                        entirePoint.push(IPathPoint)
                    }
                }
                spi.entireSubPath = entirePoint
                spis.push(spi)
            }
        }

        await this.currentDoc.pathItems.add("Primitive", spis)
        const lines = this.currentDoc.pathItems.getByName("Primitive")
        await lines.strokePath()
        await lines.remove()
    }


    async drawPersepectiveLines() {

    }

}

module.exports = {
    Drawer
}

const { Matrix, Point } = require("./Matrix");
const { Camera } = require("./Camera");
const { MultiPoly } = require("./MultiPoly");
const { PrimitivePlane } = require("./Primitive");
const { Drawer } = require("./Drawer");
const { World } = require("./World");

Array.from(document.querySelectorAll(".sp-tab")).forEach(theTab => {
  theTab.onclick = () => {
    localStorage.setItem("currentTab", theTab.getAttribute("id"));
    Array.from(document.querySelectorAll(".sp-tab")).forEach(aTab => {
      if (aTab.getAttribute("id") === theTab.getAttribute("id")) {
        aTab.classList.add("selected");
      } else {
        aTab.classList.remove("selected");
      }
    });
    Array.from(document.querySelectorAll(".sp-tab-page")).forEach(tabPage => {
      if (tabPage.getAttribute("id").startsWith(theTab.getAttribute("id"))) {
        tabPage.classList.add("visible");
      } else {
        tabPage.classList.remove("visible");
      }
    });
  }
});

let app = window.require('photoshop').app;
let constants = window.require("photoshop").constants;
let currentDoc;
let canvas_height;
let canvas_width;
let max_split;
let z_c_min;
let z_min;
let z_max;
let window_distance;

let horizontal_degree;
let horizonta_rads;
let vertical_rads;
let window_v_size;
let window_h_size;

let cameraPos = [0, 0, 0];
let cameraTargetPos = [0, 0, 0];

let normalLength;

function Init() {
  if (!app) {
    // 初期化処理．
  }
  console.log("Initializing...");
  currentDoc = app.activeDocument;
  console.log("Document Name:", currentDoc.title);
  canvas_height = currentDoc.height;
  console.log("Document Height:", currentDoc.height);
  canvas_width = currentDoc.width;
  console.log("Documen Width:", currentDoc.width);
  max_split = 20;
  z_c_min = 0.0;
  z_min = 0.1;
  z_max = 1000.0;
  calc_z_c_min();
  window_distance = 1;
  InitCanvas();
  console.log("Initialized Success.");
  normalLength = document.getElementById("inputNormal")

  return true;
}

function InitCanvas() {
  //キャンバスの初期化．
  canvas_height = currentDoc.height;
  canvas_width = currentDoc.width;

  horizontal_degree = Number(document.getElementById("cameraFOV").value) / 2;
  horizonta_rads = ang_to_rad(horizontal_degree);
  vertical_rads = horizonta_rads * canvas_height / canvas_width;
  window_v_size = window_distance * Math.tan(vertical_rads);
  window_h_size = window_distance * Math.tan(horizonta_rads);
  calc_z_c_min();
  return;
}

function ang_to_rad(ang) {
  return ang * Math.PI / 180;
}

function calc_z_c_min() {
  z_c_min = z_min / z_max;
  return z_c_min;
}

function updateSelectionEyelevel() {
  if (!Init()) {
    console.alert("Initialize Failed")
    return;
  }
  const eyelevelElement = document.getElementById("menuEyelevel");
  var i;
  while (eyelevelElement.lastChild) {
    eyelevelElement.removeChild(eyelevelElement.lastChild);
  }

  var pathItems = currentDoc.pathItems;
  for (i = 0; i < pathItems.length; i++) {
    var path = pathItems[i];
    console.log("Name", path.name, "Path length.", path.subPathItems.length, "Type:", path.kind);
    if (path.kind != constants.PathKind.NORMALPATH || path.subPathItems.length != 1) {
      console.log("Loop passed.")
      continue;
    }
    if (path.subPathItems[0].pathPoints.length != 2) {
      continue;
    }
    var newSpmenu = document.createElement("sp-menu-item");
    newSpmenu.textContent = path.name;
    newSpmenu.value = path.name;
    eyelevelElement.appendChild(newSpmenu);
  }
}

function updateSelectionTargetPaths() {
  Init();
  const tarPathElement = document.getElementById("menuTargets")
  while (tarPathElement.lastChild) {
    tarPathElement.removeChild(tarPathElement.lastChild);
  }
  const pathItems = currentDoc.pathItems
  console.log(currentDoc)
  for (let index = 0; index < pathItems.length; index++) {
    const element = pathItems[index];
    const newSpmenu = document.createElement("sp-menu-item")
    newSpmenu.textContent = element.name
    newSpmenu.value = element.name
    tarPathElement.appendChild(newSpmenu)
    console.log(element.name)
  }
}

function updateSelectionCameraPath() {
  if (!Init()) {
    console.alert("Initialize Failed")
    return;
  }
  const camPathlElement = document.getElementById("menuCameraPath");
  var i;
  while (camPathlElement.lastChild) {
    camPathlElement.removeChild(camPathlElement.lastChild);
  }

  var pathItems = currentDoc.pathItems;

  for (i = 0; i < pathItems.length; i++) {
    var path = pathItems[i];
    console.log("Name", path.name, "Path length.", path.subPathItems.length, "Type:", path.kind);
    if (path.kind != constants.PathKind.NORMALPATH || path.subPathItems.length != 1) {
      console.log("Loop passed.")
      continue;
    }
    if (path.subPathItems[0].pathPoints.length != 3) {
      continue;
    }
    var newSpmenu = document.createElement("sp-menu-item");
    newSpmenu.textContent = path.name;
    newSpmenu.value = path.name;
    camPathlElement.appendChild(newSpmenu);
  }
}

function addPath() {
  const target = document.getElementById("menuTargets")
  const candidate = document.getElementById("menuCandidate")
  let newSpmenu = document.createElement("sp-menu-item")
  console.log(target.value)
  newSpmenu.textContent = target.value
  newSpmenu.value = target.value
  candidate.appendChild(newSpmenu)
}

function updateTextEyelevel() {
  console.log("Updating text");
  if (document.getElementById("menuEyelevel").length == 0) {
    return false;
  }
  const index = document.getElementById("pickerEyelevel");
  var textElement = document.getElementById("textEyelevel");
  textElement.textContent = index.selectedIndex.value;
}

function updateTextCamPath() {
  return;
  console.log("Updating text");
  if (document.getElementById("menuCameraPath").childElementCount == 0) {
    console.log("No item");
    return false;
  }
  const indexss = document.getElementById("pickerCamerapath");
  console.log(indexss.selectedIndex);
  var textElement = document.getElementById("textCameraPath");
  textElement.textContent = indexss.value;
}

async function drawPerspective() {
  await require('photoshop').core.executeAsModal(dFunc, { "commandName": "Test command" });
}

function createScene() {
  const c_pos = [
    Number(document.getElementById("cameraPosX").value),
    Number(document.getElementById("cameraPosY").value),
    Number(document.getElementById("cameraPosZ").value)
  ]

  const t_pos = [
    Number(document.getElementById("cameraTargetX").value),
    Number(document.getElementById("cameraTargetY").value),
    Number(document.getElementById("cameraTargetZ").value)
  ]
  return new World(new Camera(c_pos, t_pos, window_distance, window_v_size, window_h_size, z_max, z_c_min, z_min, canvas_width, canvas_height));
}

async function dFunc(executionControl) {
  Init()
  let hostControl = executionControl.hostControl;

  // Get an ID for a target document
  let documentID = await currentDoc.id;

  // Suspend history state on the target document
  // This will coalesce all changes into a single history state called
  // 'Custom Command'
  let suspensionID = await hostControl.suspendHistory({
    "documentID": documentID,
    "name": "パース描画"
  });

  const renderer = new Drawer(app, currentDoc, constants)

  let pNumX = Math.trunc(Number(document.getElementById("perseLineNumX").value))
  let pNumY = Math.trunc(Number(document.getElementById("perseLineNumY").value))
  let pNumZ = Math.trunc(Number(document.getElementById("perseLineNumZ").value))

  wld = createScene()
  wld.createPerse(
    pNumX,
    pNumY,
    pNumZ
  );
  await renderer.draw(wld.getDrawObjectPerse())
  await hostControl.resumeHistory(suspensionID);

}

function addPathsToPicker(targetPickerName, subPathNum, pointsNum) {
  if (!Init()) {
    console.alert("Initialize Failed")
    return;
  }
  const pickerNormal = document.getElementById(targetPickerName);
  var i;
  while (pickerNormal.lastChild) {
    pickerNormal.removeChild(pickerNormal.lastChild);
  }

  var pathItems = currentDoc.pathItems;

  for (i = 0; i < pathItems.length; i++) {
    var path = pathItems[i];
    if (path.kind != constants.PathKind.NORMALPATH || path.subPathItems.length != subPathNum) {
      continue;
    }
    if (path.subPathItems[0].pathPoints.length != pointsNum) {
      continue;
    }
    var newSpmenu = document.createElement("sp-menu-item");
    newSpmenu.textContent = path.name;
    newSpmenu.value = path.name;
    pickerNormal.appendChild(newSpmenu);
  }
}

function updateNormalPathPicker() {
  addPathsToPicker("menuNormalLength", 1, 2)
}

function updateSelectionNormal() {
}

function updateNormalText() {
  const element = document.getElementById("pickerNormalLength")
  if (!element.value) {
    return
  }
  const t = document.getElementById("textNormal")
  const pathNormal = currentDoc.pathItems.getByName(element.value).subPathItems[0]
  const x = pathNormal.pathPoints[0].anchor[0] - pathNormal.pathPoints[1].anchor[0]
  const y = pathNormal.pathPoints[0].anchor[1] - pathNormal.pathPoints[1].anchor[1]
  const length = Math.sqrt(x ** 2 + y ** 2)
  console.log(length)
  t.textContent = "" + Math.trunc(length) + "px = 1m";
}

function pathLength(a, b) {
  const x = a.anchor[0] - b.anchor[0]
  const y = a.anchor[1] - b.anchor[1]
  const length = Math.sqrt(x ** 2 + y ** 2)
  return length
}

function calcCamera() {
  const element = document.getElementById("pickerNormalLength")
  if (!element.value) {
    return
  }
}

async function primitiveDraw(executionControl) {
  Init()
  let hostControl = executionControl.hostControl;

  // Get an ID for a target document
  let documentID = await currentDoc.id;

  // Suspend history state on the target document
  // This will coalesce all changes into a single history state called
  // 'Custom Command'
  let suspensionID = await hostControl.suspendHistory({
    "documentID": documentID,
    "name": "パース描画"
  });

  //ここから
  wld = createScene()
  const renderer = new Drawer(app, currentDoc, constants) //Drawerをrendererでインスタンス化．
  const Tprimitive = document.getElementById("menuPrimitives").value

  switch(Tprimitive){
    case plane:
      const IPrimitive = new PrimitivePlane(
        Matrix.makeVert(0, 0, 0),
        Matrix.makeScale(1, 1, 1),
        Matrix.makeRotationY(0)
      )
      console.table(wld.getDrawObject(IPrimitive.poly))
      await renderer.draw(wld.getDrawObject(IPrimitive.poly))
      break;
    
    case box:
      break

    default:
      console.warn("プリミティブが未指定です．")

      await hostControl.resumeHistory(suspensionID)
      return
  }



  //ここまで
  await hostControl.resumeHistory(suspensionID);

}

async function generatePrimitive() {
  const Tprimitive = document.getElementById("menuPrimitives").value
  console.log(Tprimitive)
  await require('photoshop').core.executeAsModal(primitiveDraw, { "commandName": "Test command" });
  

  switch (Tprimitive) {
    case plane:

      break;

    default:
      console.log("Nothing selected")
      break;
  }
}

function testFunction() {
  Init()
  const IPrimitive = new PrimitivePlane(
    Matrix.makeVert(0, 0, 0),
    Matrix.makeScale(1, 1, 1),
    Matrix.makeRotationY(0)
  )
  console.log(IPrimitive.getPoly())
  wld = createScene()
  console.log(wld.getDrawObject(IPrimitive.poly))
  console.log("IsClosed? : ", IPrimitive.IsClosed())
  wld.createPerse(3, 3, 3)
  console.log(wld.getDrawObjectPerse())
}

document.getElementById("btnGo").addEventListener("click", drawPerspective);
document.getElementById("btnUpdateCameraPath").addEventListener("click", updateSelectionCameraPath);
document.getElementById("pickerCamerapath").addEventListener("change", updateTextCamPath);
document.getElementById("updateTargetPaths").addEventListener("click", updateSelectionTargetPaths)
document.getElementById("menuTargets").addEventListener("dblclick", addPath)
document.getElementById("updateNormal").addEventListener("click", updateNormalPathPicker)
document.getElementById("pickerNormalLength").addEventListener("change", updateNormalText)
document.getElementById("btnGeneratePrimitive").addEventListener("click", generatePrimitive)
document.getElementById("btnReset").addEventListener("click", testFunction)